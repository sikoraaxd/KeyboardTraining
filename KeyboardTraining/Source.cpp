#include <SFML/Graphics.hpp> #include "Key.h" #include <iostream> #include <fstream> #include <vector> #include <exception> #include <locale>  //std::vector<Key*> setKeyboard(const char* Lang, float startX = 0, float startY = 0) //{ //    size_t  firstString = 0, //        secondString = 0, //        thirdString = 0; //    wchar_t* alphabet{}; //    if (Lang == "Rus") //    { //        firstString = 12; //        secondString = 11; //        thirdString = 9; //        alphabet = new wchar_t[32]{ L'Й', L'ц', L'у', L'к', L'е', L'н', L'г', L'ш', L'щ', L'з', L'х', L'ъ', L'ф', L'ы', L'в', L'а', L'п', //        L'р', L'о', L'л', L'д', L'ж', L'э', L'я', L'ч', L'с', L'м', L'и', L'т', L'ь', L'б', L'ю' }; //    } //    else if (Lang == "Eng") //    { //        firstString = 10; //        secondString = 9; //        thirdString = 7; //        alphabet = new wchar_t[26]{ L'й', L'w', L'e', L'к', L'е', L'н', L'г', L'ш', L'щ', L'з', L'х', L'ъ', L'ф', L'ы', L'в', L'а', L'п', //        L'р', L'о', L'л', L'д', L'ж', L'э', L'я', L'ч', L'с' }; //    } // //    std::vector<Key*> Keyboard; // //    std::string letter; //    float shiftX = 0; //    int j = 0; //    for (size_t i = 0; i < firstString; i++) //    { //        Keyboard.push_back(new Key(alphabet[j++], startX + shiftX, startY)); //        shiftX = 45 * (i + 1); //    } //    shiftX = 0; //    for (size_t i = 0; i < secondString; i++) //    { //        Keyboard.push_back(new Key(alphabet[j++], startX + shiftX + 20, startY + 45)); //        shiftX = 45 * (i + 1); //    } //    shiftX = 0; //    for (size_t i = 0; i < thirdString; i++) //    { //        Keyboard.push_back(new Key(alphabet[j++], startX + shiftX + 60, startY + 90)); //        shiftX = 45 * (i + 1); //    } // //    return Keyboard; //}  int main() {     sf::ContextSettings settings;     settings.antialiasingLevel = 8;      sf::RenderWindow window(sf::VideoMode(800, 600), "My window", sf::Style::Close, settings);     window.setFramerateLimit(1000);     sf::Font robotoFont;     robotoFont.loadFromFile("Fonts\\Roboto-Thin.ttf");     sf::Text devInfo("Hello", robotoFont, 15);     devInfo.setStyle(sf::Text::Bold);     devInfo.setFillColor(sf::Color::Black);     sf::RectangleShape bg;     bg.setSize(sf::Vector2f(800, 600));     bg.setFillColor(sf::Color::White);     sf::String pos;      std::vector<Key*> Keyboard = setKeyboard("Eng", 125, 400);     // пусть программа работает до тех пор, пока открыто окно     while (window.isOpen())     {         // проверить все события окна, которые были вызваны с последней итерации цикла         sf::Event event;         while (window.pollEvent(event))         {             // "запрос закрытия" событие: мы закрываем окно             if (event.type == sf::Event::Closed)                 window.close();              if (event.type == sf::Event::MouseMoved) {                 pos = std::to_string(event.mouseMove.x) + ", " + std::to_string(event.mouseMove.y);                 devInfo.setString(pos);             }              if ((event.type == sf::Event::KeyPressed) || (event.type == sf::Event::KeyReleased)) {                 for (size_t i = 0; i < Keyboard.size(); i++)                 {                     Keyboard[i]->switchKey(event);                  }             }             window.clear();             window.draw(bg);             window.draw(devInfo);             for (size_t i = 0; i < Keyboard.size(); i++)             {                 window.draw(*Keyboard[i]);             }              window.display();         }     }      return 0; }